// Use example for LightweightGraph, the high level wrapper for Graph

#include "lwtnn/generic/FastGraph.hh"
#include "lwtnn/parse_json.hh"
#include "lwtnn/Exceptions.hh"

#include <Eigen/Dense>

#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>

#include <iostream>
#include <fstream>
#include <cassert>

namespace {
  template<typename T>
  int run_on(const lwt::GraphConfig& config, const std::string& = "");
}


void usage(const std::string& name) {
  std::cout << "usage: " << name << " <nn config>\n"
    "\n"
    "The <nn config> file should be generated by one of the scripts in\n"
    "`converters/`.\n"
    "\n";
}

int main(int argc, char* argv[]) {
  if (argc != 2) {
    usage(argv[0]);
    exit(1);
  }
  // Read in the configuration.
  std::string in_file_name(argv[1]);
  std::ifstream in_file(in_file_name);
  auto config = lwt::parse_json_graph(in_file);

  run_on<float>(config, ", type float");
  run_on<double>(config, ", type double");
  return 0;
}
namespace {

  lwt::order_t get_input_names(const std::vector<lwt::InputNodeConfig>& cfg) {
    lwt::order_t out;
    for (const auto& node: cfg) {
      std::vector<std::string> names;
      for (const auto& input: node.variables) {
        names.emplace_back(input.name);
      }
      out.emplace_back(node.name, names);
    }
    return out;
  }

  template<typename T>
  int run_on(const lwt::GraphConfig& config,
             const std::string& more_info) {
    using namespace lwt;
    assert(config.outputs.size() > 0);

    // First build the tagger object.
    lwt::InputOrder order;
    order.scalar = get_input_names(config.inputs);
    order.sequence = get_input_names(config.input_sequences);
    lwt::generic::FastGraph<T> tagger(config, order);

    std::vector<lwt::VectorX<T>> scalars;
    for (const auto& scalar: order.scalar) {
      scalars.push_back(lwt::VectorX<T>(scalar.second.size()));
    }
    std::vector<lwt::MatrixX<T>> sequences;
    for (const auto& seq: order.sequence) {
      sequences.push_back(lwt::MatrixX<T>(seq.second.size(),20));
    }
    std::cout << "running with " << order.scalar.size() << " scalars, and "
              << order.sequence.size() << " sequences" << more_info
              << std::endl;
    lwt::VectorX<T> output = tagger.compute(scalars, sequences);
    for (int iii = 0; iii < output.size(); iii++) {
      if (iii > 0) std::cout << ", ";
      std::cout << output(iii);
    }
    std::cout << std::endl;

    return 0;
  }

}
